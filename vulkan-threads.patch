--- loader/CMakeLists.txt.orig	2018-06-07 15:14:52.245050300 +0100
+++ loader/CMakeLists.txt	2018-06-07 15:15:19.007927800 +0100
@@ -157,7 +157,7 @@
     endforeach()
 
     if (ENABLE_WIN10_ONECORE)
-    # Note  When linking your app or driver to OneCore.lib, be sure to remove any links to non-umbrella libs (such as kernel32.lib). 
+    # Note  When linking your app or driver to OneCore.lib, be sure to remove any links to non-umbrella libs (such as kernel32.lib).
         set(CMAKE_CXX_STANDARD_LIBRARIES " ") # space is intentional
         set(CMAKE_C_STANDARD_LIBRARIES ${CMAKE_CXX_STANDARD_LIBRARIES})
     endif()
@@ -206,7 +206,7 @@
         target_link_libraries(${API_LOWERCASE}-${MAJOR} OneCoreUAP.lib LIBCMT.LIB LIBCMTD.LIB LIBVCRUNTIME.LIB LIBUCRT.LIB)
         set_target_properties(${API_LOWERCASE}-${MAJOR} PROPERTIES LINK_FLAGS   "/NODEFAULTLIB")
     else()
-        target_link_libraries(${API_LOWERCASE}-${MAJOR} Cfgmgr32)
+        target_link_libraries(${API_LOWERCASE}-${MAJOR} cfgmgr32)
     endif()
 
     add_dependencies(${API_LOWERCASE}-${MAJOR} generate_helper_files loader_gen_files loader_asm_gen_files)
--- loader/CMakeLists.txt.orig	2018-06-07 15:23:52.092667100 +0100
+++ loader/CMakeLists.txt	2018-06-07 15:24:19.926744300 +0100
@@ -206,7 +206,7 @@
         target_link_libraries(${API_LOWERCASE}-${MAJOR} OneCoreUAP.lib LIBCMT.LIB LIBCMTD.LIB LIBVCRUNTIME.LIB LIBUCRT.LIB)
         set_target_properties(${API_LOWERCASE}-${MAJOR} PROPERTIES LINK_FLAGS   "/NODEFAULTLIB")
     else()
-        target_link_libraries(${API_LOWERCASE}-${MAJOR} cfgmgr32)
+        target_link_libraries(${API_LOWERCASE}-${MAJOR} boost_system-mt cfgmgr32)
     endif()
 
     add_dependencies(${API_LOWERCASE}-${MAJOR} generate_helper_files loader_gen_files loader_asm_gen_files)
--- icd/CMakeLists.txt.orig	2018-06-07 15:44:00.311383400 +0100
+++ icd/CMakeLists.txt	2018-06-07 15:44:39.320797400 +0100
@@ -107,6 +107,7 @@
     set_target_properties(copy-${target}-def-file PROPERTIES FOLDER ${LVL_TARGET_FOLDER})
     add_library(VkICD_${target} SHARED ${ARGN} VkICD_${target}.def)
     add_dependencies(VkICD_${target} generate_icd_files)
+    target_link_Libraries(VkICD_${target} boost_system-mt)
     #target_link_Libraries(VkICD_${target} VkICD_utils)
     #add_dependencies(VkICD_${target} generate_helper_files VkICD_utils)
     endmacro()
--- layers/object_tracker.h.orig	2018-06-07 15:49:48.567409600 +0100
+++ layers/object_tracker.h	2018-06-07 15:50:40.825718700 +0100
@@ -20,7 +20,7 @@
  * Author: Tobin Ehlis <tobin@lunarg.com>
  */
 
-#include <mutex>
+#include <boost/thread.hpp>
 #include <cinttypes>
 #include <stdio.h>
 #include <stdlib.h>
@@ -134,7 +134,7 @@
 extern std::unordered_map<void *, layer_data *> layer_data_map;
 extern device_table_map ot_device_table_map;
 extern instance_table_map ot_instance_table_map;
-extern std::mutex global_lock;
+extern boost::mutex global_lock;
 extern uint64_t object_track_index;
 extern uint32_t loader_layer_if_version;
 extern const std::unordered_map<std::string, void *> name_to_funcptr_map;
--- scripts/object_tracker_generator.py.orig	2018-06-07 15:59:11.839243400 +0100
+++ scripts/object_tracker_generator.py	2018-06-07 16:00:23.723129600 +0100
@@ -611,7 +611,7 @@
     #
     # Insert a lock_guard line
     def lock_guard(self, indent):
-        return '%sstd::lock_guard<std::mutex> lock(global_lock);\n' % indent
+        return '%sboost::lock_guard<boost::mutex> lock(global_lock);\n' % indent
     #
     # Determine if a struct has an object as a member or an embedded member
     def struct_contains_object(self, struct_item):
@@ -650,7 +650,7 @@
         return object_list
     #
     # Construct list of extension structs containing handles, or extension structs that share a <validextensionstructs>
-    # tag WITH an extension struct containing handles. 
+    # tag WITH an extension struct containing handles.
     def GenerateCommandWrapExtensionList(self):
         for struct in self.structMembers:
             if (len(struct.members) > 1) and struct.members[1].extstructs is not None:
@@ -693,7 +693,7 @@
             handle_name = params[-1].find('name')
             create_obj_code += '%sif (VK_SUCCESS == result) {\n' % (indent)
             indent = self.incIndent(indent)
-            create_obj_code += '%sstd::lock_guard<std::mutex> lock(global_lock);\n' % (indent)
+            create_obj_code += '%sboost::lock_guard<boost::mutex> lock(global_lock);\n' % (indent)
             object_dest = '*%s' % handle_name.text
             if object_array == True:
                 create_obj_code += '%sfor (uint32_t index = 0; index < %s; index++) {\n' % (indent, cmd_info[-1].len)
@@ -730,7 +730,7 @@
                     # Call Destroy a single time
                     destroy_obj_code += '%sif (skip) return;\n' % indent
                     destroy_obj_code += '%s{\n' % indent
-                    destroy_obj_code += '%s    std::lock_guard<std::mutex> lock(global_lock);\n' % indent
+                    destroy_obj_code += '%s    boost::lock_guard<boost::mutex> lock(global_lock);\n' % indent
                     destroy_obj_code += '%s    DestroyObject(%s, %s, %s, pAllocator, %s, %s);\n' % (indent, cmd_info[0].name, cmd_info[param].name, self.GetVulkanObjType(cmd_info[param].type), compatalloc_vuid, nullalloc_vuid)
                     destroy_obj_code += '%s}\n' % indent
         return object_array, destroy_obj_code
--- scripts/unique_objects_generator.py.orig	2018-06-07 16:06:12.166956900 +0100
+++ scripts/unique_objects_generator.py	2018-06-07 16:07:12.772471000 +0100
@@ -408,7 +408,7 @@
     #
     # Insert a lock_guard line
     def lock_guard(self, indent):
-        return '%sstd::lock_guard<std::mutex> lock(global_lock);\n' % indent
+        return '%sboost::lock_guard<boost::mutex> lock(global_lock);\n' % indent
     #
     # Determine if a struct has an NDO as a member or an embedded member
     def struct_contains_ndo(self, struct_item):
@@ -552,7 +552,7 @@
             handle_name = params[-1].find('name')
             create_ndo_code += '%sif (VK_SUCCESS == result) {\n' % (indent)
             indent = self.incIndent(indent)
-            create_ndo_code += '%sstd::lock_guard<std::mutex> lock(global_lock);\n' % (indent)
+            create_ndo_code += '%sboost::lock_guard<boost::mutex> lock(global_lock);\n' % (indent)
             ndo_dest = '*%s' % handle_name.text
             if ndo_array == True:
                 create_ndo_code += '%sfor (uint32_t index0 = 0; index0 < %s; index0++) {\n' % (indent, cmd_info[-1].len)
@@ -582,7 +582,7 @@
                     # This API is freeing an array of handles.  Remove them from the unique_id map.
                     destroy_ndo_code += '%sif ((VK_SUCCESS == result) && (%s)) {\n' % (indent, cmd_info[param].name)
                     indent = self.incIndent(indent)
-                    destroy_ndo_code += '%sstd::unique_lock<std::mutex> lock(global_lock);\n' % (indent)
+                    destroy_ndo_code += '%sboost::unique_lock<boost::mutex> lock(global_lock);\n' % (indent)
                     destroy_ndo_code += '%sfor (uint32_t index0 = 0; index0 < %s; index0++) {\n' % (indent, cmd_info[param].len)
                     indent = self.incIndent(indent)
                     destroy_ndo_code += '%s%s handle = %s[index0];\n' % (indent, cmd_info[param].type, cmd_info[param].name)
@@ -594,7 +594,7 @@
                     destroy_ndo_code += '%s}\n' % indent
                 else:
                     # Remove a single handle from the map
-                    destroy_ndo_code += '%sstd::unique_lock<std::mutex> lock(global_lock);\n' % (indent)
+                    destroy_ndo_code += '%sboost::unique_lock<boost::mutex> lock(global_lock);\n' % (indent)
                     destroy_ndo_code += '%suint64_t %s_id = reinterpret_cast<uint64_t &>(%s);\n' % (indent, cmd_info[param].name, cmd_info[param].name)
                     destroy_ndo_code += '%s%s = (%s)unique_id_mapping[%s_id];\n' % (indent, cmd_info[param].name, cmd_info[param].type, cmd_info[param].name)
                     destroy_ndo_code += '%sunique_id_mapping.erase(%s_id);\n' % (indent, cmd_info[param].name)
--- scripts/parameter_validation_generator.py.orig	2018-06-07 16:12:31.928577900 +0100
+++ scripts/parameter_validation_generator.py	2018-06-07 16:13:26.733247300 +0100
@@ -287,7 +287,7 @@
         self.newline()
         write('namespace parameter_validation {', file = self.outFile)
         self.newline()
-        write('extern std::mutex global_lock;', file = self.outFile)
+        write('extern boost::mutex global_lock;', file = self.outFile)
         write('extern std::unordered_map<void *, layer_data *> layer_data_map;', file = self.outFile)
         write('extern std::unordered_map<void *, instance_layer_data *> instance_layer_data_map;', file = self.outFile)
         self.newline()
@@ -1202,7 +1202,7 @@
                         else:
                             raise Exception("Unknown result type: " + command.result)
 
-                    cmdDef += '%sstd::unique_lock<std::mutex> lock(global_lock);\n' % indent
+                    cmdDef += '%sboost::unique_lock<boost::mutex> lock(global_lock);\n' % indent
                 for line in lines:
                     cmdDef += '\n'
                     if type(line) is list:
--- layers/hash_util.h.orig	2018-06-07 16:16:04.632929100 +0100
+++ layers/hash_util.h	2018-06-07 16:17:05.698598500 +0100
@@ -25,7 +25,7 @@
 #include <functional>
 #include <limits>
 #include <memory>
-#include <mutex>
+#include <boost/thread.hpp>
 #include <type_traits>
 #include <unordered_set>
 #include <vector>
@@ -154,8 +154,8 @@
         bool operator()(const Id &lhs, const Id &rhs) const { return KeyEqual()(*lhs, *rhs); }
     };
     using Dict = std::unordered_set<Id, HashKeyValue, KeyValueEqual>;
-    using Lock = std::mutex;
-    using Guard = std::lock_guard<Lock>;
+    using Lock = boost::mutex;
+    using Guard = boost::lock_guard<Lock>;
     Lock lock;
     Dict dict;
 };
--- layers/threading.h.orig	2018-06-07 16:17:44.616619400 +0100
+++ layers/threading.h	2018-06-07 16:19:51.946791900 +0100
@@ -21,7 +21,7 @@
 #ifndef THREADING_H
 #define THREADING_H
 #include <condition_variable>
-#include <mutex>
+#include <boost/thread.hpp>
 #include <vector>
 #include "vk_layer_config.h"
 #include "vk_layer_logging.h"
@@ -83,7 +83,7 @@
     const char *typeName;
     VkDebugReportObjectTypeEXT objectType;
     std::unordered_map<T, object_use_data> uses;
-    std::mutex counter_lock;
+    boost::mutex counter_lock;
     std::condition_variable counter_condition;
     void startWrite(debug_report_data *report_data, T object) {
         if (object == VK_NULL_HANDLE) {
@@ -91,7 +91,7 @@
         }
         bool skipCall = false;
         loader_platform_thread_id tid = loader_platform_get_thread_id();
-        std::unique_lock<std::mutex> lock(counter_lock);
+        boost::unique_lock<boost::mutex> lock(counter_lock);
         if (uses.find(object) == uses.end()) {
             // There is no current use of the object.  Record writer thread.
             struct object_use_data *use_data = &uses[object];
@@ -165,7 +165,7 @@
             return;
         }
         // Object is no longer in use
-        std::unique_lock<std::mutex> lock(counter_lock);
+        boost::unique_lock<boost::mutex> lock(counter_lock);
         uses[object].writer_count -= 1;
         if ((uses[object].reader_count == 0) && (uses[object].writer_count == 0)) {
             uses.erase(object);
@@ -181,7 +181,7 @@
         }
         bool skipCall = false;
         loader_platform_thread_id tid = loader_platform_get_thread_id();
-        std::unique_lock<std::mutex> lock(counter_lock);
+        boost::unique_lock<boost::mutex> lock(counter_lock);
         if (uses.find(object) == uses.end()) {
             // There is no current use of the object.  Record reader count
             struct object_use_data *use_data = &uses[object];
@@ -217,7 +217,7 @@
         if (object == VK_NULL_HANDLE) {
             return;
         }
-        std::unique_lock<std::mutex> lock(counter_lock);
+        boost::unique_lock<boost::mutex> lock(counter_lock);
         uses[object].reader_count -= 1;
         if ((uses[object].reader_count == 0) && (uses[object].writer_count == 0)) {
             uses.erase(object);
@@ -392,13 +392,13 @@
 #endif  // DISTINCT_NONDISPATCHABLE_HANDLES
 
 static std::unordered_map<void *, layer_data *> layer_data_map;
-static std::mutex command_pool_lock;
+static boost::mutex command_pool_lock;
 static std::unordered_map<VkCommandBuffer, VkCommandPool> command_pool_map;
 
 // VkCommandBuffer needs check for implicit use of command pool
 static void startWriteObject(struct layer_data *my_data, VkCommandBuffer object, bool lockPool = true) {
     if (lockPool) {
-        std::unique_lock<std::mutex> lock(command_pool_lock);
+        boost::unique_lock<boost::mutex> lock(command_pool_lock);
         VkCommandPool pool = command_pool_map[object];
         lock.unlock();
         startWriteObject(my_data, pool);
@@ -408,14 +408,14 @@
 static void finishWriteObject(struct layer_data *my_data, VkCommandBuffer object, bool lockPool = true) {
     my_data->c_VkCommandBuffer.finishWrite(object);
     if (lockPool) {
-        std::unique_lock<std::mutex> lock(command_pool_lock);
+        boost::unique_lock<boost::mutex> lock(command_pool_lock);
         VkCommandPool pool = command_pool_map[object];
         lock.unlock();
         finishWriteObject(my_data, pool);
     }
 }
 static void startReadObject(struct layer_data *my_data, VkCommandBuffer object) {
-    std::unique_lock<std::mutex> lock(command_pool_lock);
+    boost::unique_lock<boost::mutex> lock(command_pool_lock);
     VkCommandPool pool = command_pool_map[object];
     lock.unlock();
     startReadObject(my_data, pool);
@@ -423,7 +423,7 @@
 }
 static void finishReadObject(struct layer_data *my_data, VkCommandBuffer object) {
     my_data->c_VkCommandBuffer.finishRead(object);
-    std::unique_lock<std::mutex> lock(command_pool_lock);
+    boost::unique_lock<boost::mutex> lock(command_pool_lock);
     VkCommandPool pool = command_pool_map[object];
     lock.unlock();
     finishReadObject(my_data, pool);
--- layers/unique_objects.cpp.orig	2018-06-07 16:25:56.329153900 +0100
+++ layers/unique_objects.cpp	2018-06-07 16:29:53.019613700 +0100
@@ -30,6 +30,7 @@
 #include <list>
 #include <memory>
 #include <algorithm>
+#include <boost/thread.hpp>
 
 // For Windows, this #include must come before other Vk headers.
 #include "vk_loader_platform.h"
@@ -308,7 +309,7 @@
     layer_data *device_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
     safe_VkComputePipelineCreateInfo *local_pCreateInfos = NULL;
     if (pCreateInfos) {
-        std::lock_guard<std::mutex> lock(global_lock);
+        boost::lock_guard<boost::mutex> lock(global_lock);
         local_pCreateInfos = new safe_VkComputePipelineCreateInfo[createInfoCount];
         for (uint32_t idx0 = 0; idx0 < createInfoCount; ++idx0) {
             local_pCreateInfos[idx0].initialize(&pCreateInfos[idx0]);
@@ -324,7 +325,7 @@
         }
     }
     if (pipelineCache) {
-        std::lock_guard<std::mutex> lock(global_lock);
+        boost::lock_guard<boost::mutex> lock(global_lock);
         pipelineCache = Unwrap(pipelineCache);
     }
 
@@ -332,7 +333,7 @@
                                                                          local_pCreateInfos->ptr(), pAllocator, pPipelines);
     delete[] local_pCreateInfos;
     {
-        std::lock_guard<std::mutex> lock(global_lock);
+        boost::lock_guard<boost::mutex> lock(global_lock);
         for (uint32_t i = 0; i < createInfoCount; ++i) {
             if (pPipelines[i] != VK_NULL_HANDLE) {
                 pPipelines[i] = WrapNew(pPipelines[i]);
@@ -349,7 +350,7 @@
     safe_VkGraphicsPipelineCreateInfo *local_pCreateInfos = nullptr;
     if (pCreateInfos) {
         local_pCreateInfos = new safe_VkGraphicsPipelineCreateInfo[createInfoCount];
-        std::lock_guard<std::mutex> lock(global_lock);
+        boost::lock_guard<boost::mutex> lock(global_lock);
         for (uint32_t idx0 = 0; idx0 < createInfoCount; ++idx0) {
             bool uses_color_attachment = false;
             bool uses_depthstencil_attachment = false;
@@ -385,7 +386,7 @@
         }
     }
     if (pipelineCache) {
-        std::lock_guard<std::mutex> lock(global_lock);
+        boost::lock_guard<boost::mutex> lock(global_lock);
         pipelineCache = Unwrap(pipelineCache);
     }
 
@@ -393,7 +394,7 @@
                                                                           local_pCreateInfos->ptr(), pAllocator, pPipelines);
     delete[] local_pCreateInfos;
     {
-        std::lock_guard<std::mutex> lock(global_lock);
+        boost::lock_guard<boost::mutex> lock(global_lock);
         for (uint32_t i = 0; i < createInfoCount; ++i) {
             if (pPipelines[i] != VK_NULL_HANDLE) {
                 pPipelines[i] = WrapNew(pPipelines[i]);
@@ -426,7 +427,7 @@
     layer_data *dev_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
     VkResult result = dev_data->dispatch_table.CreateRenderPass(device, pCreateInfo, pAllocator, pRenderPass);
     if (VK_SUCCESS == result) {
-        std::lock_guard<std::mutex> lock(global_lock);
+        boost::lock_guard<boost::mutex> lock(global_lock);
 
         PostCallCreateRenderPass(dev_data, pCreateInfo, *pRenderPass);
 
@@ -441,7 +442,7 @@
 
 VKAPI_ATTR void VKAPI_CALL DestroyRenderPass(VkDevice device, VkRenderPass renderPass, const VkAllocationCallbacks *pAllocator) {
     layer_data *dev_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
-    std::unique_lock<std::mutex> lock(global_lock);
+    boost::unique_lock<boost::mutex> lock(global_lock);
     uint64_t renderPass_id = reinterpret_cast<uint64_t &>(renderPass);
     renderPass = (VkRenderPass)unique_id_mapping[renderPass_id];
     unique_id_mapping.erase(renderPass_id);
@@ -457,7 +458,7 @@
     layer_data *my_map_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
     safe_VkSwapchainCreateInfoKHR *local_pCreateInfo = NULL;
     if (pCreateInfo) {
-        std::lock_guard<std::mutex> lock(global_lock);
+        boost::lock_guard<boost::mutex> lock(global_lock);
         local_pCreateInfo = new safe_VkSwapchainCreateInfoKHR(pCreateInfo);
         local_pCreateInfo->oldSwapchain = Unwrap(pCreateInfo->oldSwapchain);
         // Surface is instance-level object
@@ -468,7 +469,7 @@
     delete local_pCreateInfo;
 
     if (VK_SUCCESS == result) {
-        std::lock_guard<std::mutex> lock(global_lock);
+        boost::lock_guard<boost::mutex> lock(global_lock);
         *pSwapchain = WrapNew(*pSwapchain);
     }
     return result;
@@ -480,7 +481,7 @@
     layer_data *dev_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
     safe_VkSwapchainCreateInfoKHR *local_pCreateInfos = NULL;
     {
-        std::lock_guard<std::mutex> lock(global_lock);
+        boost::lock_guard<boost::mutex> lock(global_lock);
         if (pCreateInfos) {
             local_pCreateInfos = new safe_VkSwapchainCreateInfoKHR[swapchainCount];
             for (uint32_t i = 0; i < swapchainCount; ++i) {
@@ -499,7 +500,7 @@
                                                                          pAllocator, pSwapchains);
     delete[] local_pCreateInfos;
     if (VK_SUCCESS == result) {
-        std::lock_guard<std::mutex> lock(global_lock);
+        boost::lock_guard<boost::mutex> lock(global_lock);
         for (uint32_t i = 0; i < swapchainCount; i++) {
             pSwapchains[i] = WrapNew(pSwapchains[i]);
         }
@@ -512,14 +513,14 @@
     layer_data *my_device_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
     VkSwapchainKHR wrapped_swapchain_handle = swapchain;
     if (VK_NULL_HANDLE != swapchain) {
-        std::lock_guard<std::mutex> lock(global_lock);
+        boost::lock_guard<boost::mutex> lock(global_lock);
         swapchain = Unwrap(swapchain);
     }
     VkResult result =
         my_device_data->dispatch_table.GetSwapchainImagesKHR(device, swapchain, pSwapchainImageCount, pSwapchainImages);
     if ((VK_SUCCESS == result) || (VK_INCOMPLETE == result)) {
         if ((*pSwapchainImageCount > 0) && pSwapchainImages) {
-            std::lock_guard<std::mutex> lock(global_lock);
+            boost::lock_guard<boost::mutex> lock(global_lock);
             auto &wrapped_swapchain_image_handles = my_device_data->swapchain_wrapped_image_handle_map[wrapped_swapchain_handle];
             for (uint32_t i = static_cast<uint32_t>(wrapped_swapchain_image_handles.size()); i < *pSwapchainImageCount; i++) {
                 wrapped_swapchain_image_handles.emplace_back(WrapNew(pSwapchainImages[i]));
@@ -534,7 +535,7 @@
 
 VKAPI_ATTR void VKAPI_CALL DestroySwapchainKHR(VkDevice device, VkSwapchainKHR swapchain, const VkAllocationCallbacks *pAllocator) {
     layer_data *dev_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
-    std::unique_lock<std::mutex> lock(global_lock);
+    boost::unique_lock<boost::mutex> lock(global_lock);
 
     auto &image_array = dev_data->swapchain_wrapped_image_handle_map[swapchain];
     for (auto &image_handle : image_array) {
@@ -553,7 +554,7 @@
     layer_data *dev_data = GetLayerDataPtr(get_dispatch_key(queue), layer_data_map);
     safe_VkPresentInfoKHR *local_pPresentInfo = NULL;
     {
-        std::lock_guard<std::mutex> lock(global_lock);
+        boost::lock_guard<boost::mutex> lock(global_lock);
         if (pPresentInfo) {
             local_pPresentInfo = new safe_VkPresentInfoKHR(pPresentInfo);
             if (local_pPresentInfo->pWaitSemaphores) {
@@ -590,7 +591,7 @@
     layer_data *dev_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
     safe_VkDescriptorUpdateTemplateCreateInfo *local_create_info = NULL;
     {
-        std::lock_guard<std::mutex> lock(global_lock);
+        boost::lock_guard<boost::mutex> lock(global_lock);
         if (pCreateInfo) {
             local_create_info = new safe_VkDescriptorUpdateTemplateCreateInfo(pCreateInfo);
             if (pCreateInfo->descriptorSetLayout) {
@@ -604,7 +605,7 @@
     VkResult result = dev_data->dispatch_table.CreateDescriptorUpdateTemplate(device, local_create_info->ptr(), pAllocator,
                                                                               pDescriptorUpdateTemplate);
     if (VK_SUCCESS == result) {
-        std::lock_guard<std::mutex> lock(global_lock);
+        boost::lock_guard<boost::mutex> lock(global_lock);
         *pDescriptorUpdateTemplate = WrapNew(*pDescriptorUpdateTemplate);
 
         // Shadow template createInfo for later updates
@@ -622,7 +623,7 @@
     layer_data *dev_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
     safe_VkDescriptorUpdateTemplateCreateInfo *local_create_info = NULL;
     {
-        std::lock_guard<std::mutex> lock(global_lock);
+        boost::lock_guard<boost::mutex> lock(global_lock);
         if (pCreateInfo) {
             local_create_info = new safe_VkDescriptorUpdateTemplateCreateInfo(pCreateInfo);
             if (pCreateInfo->descriptorSetLayout) {
@@ -636,7 +637,7 @@
     VkResult result = dev_data->dispatch_table.CreateDescriptorUpdateTemplateKHR(device, local_create_info->ptr(), pAllocator,
                                                                                  pDescriptorUpdateTemplate);
     if (VK_SUCCESS == result) {
-        std::lock_guard<std::mutex> lock(global_lock);
+        boost::lock_guard<boost::mutex> lock(global_lock);
         *pDescriptorUpdateTemplate = WrapNew(*pDescriptorUpdateTemplate);
 
         // Shadow template createInfo for later updates
@@ -650,7 +651,7 @@
 VKAPI_ATTR void VKAPI_CALL DestroyDescriptorUpdateTemplate(VkDevice device, VkDescriptorUpdateTemplateKHR descriptorUpdateTemplate,
                                                            const VkAllocationCallbacks *pAllocator) {
     layer_data *dev_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
-    std::unique_lock<std::mutex> lock(global_lock);
+    boost::unique_lock<boost::mutex> lock(global_lock);
     uint64_t descriptor_update_template_id = reinterpret_cast<uint64_t &>(descriptorUpdateTemplate);
     dev_data->desc_template_map.erase(descriptor_update_template_id);
     descriptorUpdateTemplate = (VkDescriptorUpdateTemplate)unique_id_mapping[descriptor_update_template_id];
@@ -664,7 +665,7 @@
                                                               VkDescriptorUpdateTemplateKHR descriptorUpdateTemplate,
                                                               const VkAllocationCallbacks *pAllocator) {
     layer_data *dev_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
-    std::unique_lock<std::mutex> lock(global_lock);
+    boost::unique_lock<boost::mutex> lock(global_lock);
     uint64_t descriptor_update_template_id = reinterpret_cast<uint64_t &>(descriptorUpdateTemplate);
     dev_data->desc_template_map.erase(descriptor_update_template_id);
     descriptorUpdateTemplate = (VkDescriptorUpdateTemplate)unique_id_mapping[descriptor_update_template_id];
@@ -762,7 +763,7 @@
     layer_data *dev_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
     uint64_t template_handle = reinterpret_cast<uint64_t &>(descriptorUpdateTemplate);
     {
-        std::lock_guard<std::mutex> lock(global_lock);
+        boost::lock_guard<boost::mutex> lock(global_lock);
         descriptorSet = Unwrap(descriptorSet);
         descriptorUpdateTemplate = (VkDescriptorUpdateTemplate)unique_id_mapping[template_handle];
     }
@@ -779,7 +780,7 @@
     uint64_t template_handle = reinterpret_cast<uint64_t &>(descriptorUpdateTemplate);
     void *unwrapped_buffer = nullptr;
     {
-        std::lock_guard<std::mutex> lock(global_lock);
+        boost::lock_guard<boost::mutex> lock(global_lock);
         descriptorSet = Unwrap(descriptorSet);
         descriptorUpdateTemplate = (VkDescriptorUpdateTemplate)unique_id_mapping[template_handle];
         unwrapped_buffer = BuildUnwrappedUpdateTemplateBuffer(dev_data, template_handle, pData);
@@ -795,7 +796,7 @@
     uint64_t template_handle = reinterpret_cast<uint64_t &>(descriptorUpdateTemplate);
     void *unwrapped_buffer = nullptr;
     {
-        std::lock_guard<std::mutex> lock(global_lock);
+        boost::lock_guard<boost::mutex> lock(global_lock);
         descriptorUpdateTemplate = Unwrap(descriptorUpdateTemplate);
         layout = Unwrap(layout);
         unwrapped_buffer = BuildUnwrappedUpdateTemplateBuffer(dev_data, template_handle, pData);
@@ -813,7 +814,7 @@
     VkResult result =
         my_map_data->dispatch_table.GetPhysicalDeviceDisplayPropertiesKHR(physicalDevice, pPropertyCount, pProperties);
     if ((result == VK_SUCCESS || result == VK_INCOMPLETE) && pProperties) {
-        std::lock_guard<std::mutex> lock(global_lock);
+        boost::lock_guard<boost::mutex> lock(global_lock);
         for (uint32_t idx0 = 0; idx0 < *pPropertyCount; ++idx0) {
             pProperties[idx0].display = WrapNew(pProperties[idx0].display);
         }
@@ -828,7 +829,7 @@
         my_map_data->dispatch_table.GetDisplayPlaneSupportedDisplaysKHR(physicalDevice, planeIndex, pDisplayCount, pDisplays);
     if (VK_SUCCESS == result) {
         if ((*pDisplayCount > 0) && pDisplays) {
-            std::lock_guard<std::mutex> lock(global_lock);
+            boost::lock_guard<boost::mutex> lock(global_lock);
             for (uint32_t i = 0; i < *pDisplayCount; i++) {
                 // TODO: this looks like it really wants a /reverse/ mapping. What's going on here?
                 auto it = unique_id_mapping.find(reinterpret_cast<const uint64_t &>(pDisplays[i]));
@@ -844,13 +845,13 @@
                                                            uint32_t *pPropertyCount, VkDisplayModePropertiesKHR *pProperties) {
     instance_layer_data *my_map_data = GetLayerDataPtr(get_dispatch_key(physicalDevice), instance_layer_data_map);
     {
-        std::lock_guard<std::mutex> lock(global_lock);
+        boost::lock_guard<boost::mutex> lock(global_lock);
         display = Unwrap(display);
     }
 
     VkResult result = my_map_data->dispatch_table.GetDisplayModePropertiesKHR(physicalDevice, display, pPropertyCount, pProperties);
     if (result == VK_SUCCESS && pProperties) {
-        std::lock_guard<std::mutex> lock(global_lock);
+        boost::lock_guard<boost::mutex> lock(global_lock);
         for (uint32_t idx0 = 0; idx0 < *pPropertyCount; ++idx0) {
             pProperties[idx0].displayMode = WrapNew(pProperties[idx0].displayMode);
         }
@@ -862,7 +863,7 @@
                                                               uint32_t planeIndex, VkDisplayPlaneCapabilitiesKHR *pCapabilities) {
     instance_layer_data *dev_data = GetLayerDataPtr(get_dispatch_key(physicalDevice), instance_layer_data_map);
     {
-        std::lock_guard<std::mutex> lock(global_lock);
+        boost::lock_guard<boost::mutex> lock(global_lock);
         mode = Unwrap(mode);
     }
     VkResult result = dev_data->dispatch_table.GetDisplayPlaneCapabilitiesKHR(physicalDevice, mode, planeIndex, pCapabilities);
@@ -874,7 +875,7 @@
     layer_data *device_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
     safe_VkDebugMarkerObjectTagInfoEXT local_tag_info(pTagInfo);
     {
-        std::lock_guard<std::mutex> lock(global_lock);
+        boost::lock_guard<boost::mutex> lock(global_lock);
         auto it = unique_id_mapping.find(reinterpret_cast<uint64_t &>(local_tag_info.object));
         if (it != unique_id_mapping.end()) {
             local_tag_info.object = it->second;
@@ -889,7 +890,7 @@
     layer_data *device_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
     safe_VkDebugMarkerObjectNameInfoEXT local_name_info(pNameInfo);
     {
-        std::lock_guard<std::mutex> lock(global_lock);
+        boost::lock_guard<boost::mutex> lock(global_lock);
         auto it = unique_id_mapping.find(reinterpret_cast<uint64_t &>(local_name_info.object));
         if (it != unique_id_mapping.end()) {
             local_name_info.object = it->second;
@@ -905,7 +906,7 @@
     layer_data *device_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
     safe_VkDebugUtilsObjectTagInfoEXT local_tag_info(pTagInfo);
     {
-        std::lock_guard<std::mutex> lock(global_lock);
+        boost::lock_guard<boost::mutex> lock(global_lock);
         auto it = unique_id_mapping.find(reinterpret_cast<uint64_t &>(local_tag_info.objectHandle));
         if (it != unique_id_mapping.end()) {
             local_tag_info.objectHandle = it->second;
@@ -920,7 +921,7 @@
     layer_data *device_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
     safe_VkDebugUtilsObjectNameInfoEXT local_name_info(pNameInfo);
     {
-        std::lock_guard<std::mutex> lock(global_lock);
+        boost::lock_guard<boost::mutex> lock(global_lock);
         auto it = unique_id_mapping.find(reinterpret_cast<uint64_t &>(local_name_info.objectHandle));
         if (it != unique_id_mapping.end()) {
             local_name_info.objectHandle = it->second;
--- layers/core_validation.cpp.orig	2018-06-07 16:36:28.065066800 +0100
+++ layers/core_validation.cpp	2018-06-07 16:37:30.215610600 +0100
@@ -43,7 +43,7 @@
 #include <list>
 #include <map>
 #include <memory>
-#include <mutex>
+#include <boost/thread.hpp>
 #include <set>
 #include <sstream>
 #include <stdio.h>
@@ -84,9 +84,9 @@
 // This intentionally includes a cpp file
 #include "vk_safe_struct.cpp"
 
-using mutex_t = std::mutex;
-using lock_guard_t = std::lock_guard<mutex_t>;
-using unique_lock_t = std::unique_lock<mutex_t>;
+using mutex_t = boost::mutex;
+using lock_guard_t = boost::lock_guard<mutex_t>;
+using unique_lock_t = boost::unique_lock<mutex_t>;
 
 // These functions are defined *outside* the core_validation namespace as their type
 // is also defined outside that namespace
--- layers/object_tracker_utils.cpp.orig	2018-06-07 16:41:38.305577700 +0100
+++ layers/object_tracker_utils.cpp	2018-06-07 16:43:46.316776500 +0100
@@ -27,7 +27,7 @@
 std::unordered_map<void *, layer_data *> layer_data_map;
 device_table_map ot_device_table_map;
 instance_table_map ot_instance_table_map;
-std::mutex global_lock;
+boost::mutex global_lock;
 uint64_t object_track_index = 0;
 uint32_t loader_layer_if_version = CURRENT_LOADER_LAYER_INTERFACE_VERSION;
 
@@ -249,7 +249,7 @@
                                                    const VkWriteDescriptorSet *pDescriptorWrites) {
     bool skip = false;
     {
-        std::lock_guard<std::mutex> lock(global_lock);
+        boost::lock_guard<boost::mutex> lock(global_lock);
         skip |= ValidateObject(commandBuffer, commandBuffer, kVulkanObjectTypeCommandBuffer, false, VALIDATION_ERROR_1be02401,
                                VALIDATION_ERROR_1be00009);
         skip |= ValidateObject(commandBuffer, layout, kVulkanObjectTypePipelineLayout, false, VALIDATION_ERROR_1be0be01,
@@ -322,7 +322,7 @@
 }
 
 VKAPI_ATTR void VKAPI_CALL DestroyInstance(VkInstance instance, const VkAllocationCallbacks *pAllocator) {
-    std::unique_lock<std::mutex> lock(global_lock);
+    boost::unique_lock<boost::mutex> lock(global_lock);
 
     dispatch_key key = get_dispatch_key(instance);
     layer_data *instance_data = GetLayerDataPtr(key, layer_data_map);
@@ -413,7 +413,7 @@
 }
 
 VKAPI_ATTR void VKAPI_CALL DestroyDevice(VkDevice device, const VkAllocationCallbacks *pAllocator) {
-    std::unique_lock<std::mutex> lock(global_lock);
+    boost::unique_lock<boost::mutex> lock(global_lock);
     layer_data *device_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
     ValidateObject(device, device, kVulkanObjectTypeDevice, true, VALIDATION_ERROR_24a05601, VALIDATION_ERROR_UNDEFINED);
     DestroyObject(device_data->instance, device, kVulkanObjectTypeDevice, pAllocator, VALIDATION_ERROR_24a002f6,
@@ -438,7 +438,7 @@
 }
 
 VKAPI_ATTR void VKAPI_CALL GetDeviceQueue(VkDevice device, uint32_t queueFamilyIndex, uint32_t queueIndex, VkQueue *pQueue) {
-    std::unique_lock<std::mutex> lock(global_lock);
+    boost::unique_lock<boost::mutex> lock(global_lock);
     ValidateObject(device, device, kVulkanObjectTypeDevice, false, VALIDATION_ERROR_29605601, VALIDATION_ERROR_UNDEFINED);
     lock.unlock();
 
@@ -450,7 +450,7 @@
 }
 
 VKAPI_ATTR void VKAPI_CALL GetDeviceQueue2(VkDevice device, const VkDeviceQueueInfo2 *pQueueInfo, VkQueue *pQueue) {
-    std::unique_lock<std::mutex> lock(global_lock);
+    boost::unique_lock<boost::mutex> lock(global_lock);
     ValidateObject(device, device, kVulkanObjectTypeDevice, false, VALIDATION_ERROR_43405601, VALIDATION_ERROR_UNDEFINED);
     lock.unlock();
 
@@ -468,7 +468,7 @@
                                                 const VkCopyDescriptorSet *pDescriptorCopies) {
     bool skip = false;
     {
-        std::lock_guard<std::mutex> lock(global_lock);
+        boost::lock_guard<boost::mutex> lock(global_lock);
         skip |=
             ValidateObject(device, device, kVulkanObjectTypeDevice, false, VALIDATION_ERROR_33c05601, VALIDATION_ERROR_UNDEFINED);
         if (pDescriptorCopies) {
@@ -500,7 +500,7 @@
                                                       const VkComputePipelineCreateInfo *pCreateInfos,
                                                       const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines) {
     bool skip = VK_FALSE;
-    std::unique_lock<std::mutex> lock(global_lock);
+    boost::unique_lock<boost::mutex> lock(global_lock);
     skip |= ValidateObject(device, device, kVulkanObjectTypeDevice, false, VALIDATION_ERROR_1f205601, VALIDATION_ERROR_UNDEFINED);
     if (pCreateInfos) {
         for (uint32_t idx0 = 0; idx0 < createInfoCount; ++idx0) {
@@ -544,7 +544,7 @@
 VKAPI_ATTR VkResult VKAPI_CALL ResetDescriptorPool(VkDevice device, VkDescriptorPool descriptorPool,
                                                    VkDescriptorPoolResetFlags flags) {
     bool skip = false;
-    std::unique_lock<std::mutex> lock(global_lock);
+    boost::unique_lock<boost::mutex> lock(global_lock);
     layer_data *device_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
     skip |= ValidateObject(device, device, kVulkanObjectTypeDevice, false, VALIDATION_ERROR_32a05601, VALIDATION_ERROR_UNDEFINED);
     skip |= ValidateObject(device, descriptorPool, kVulkanObjectTypeDescriptorPool, false, VALIDATION_ERROR_32a04601,
@@ -572,7 +572,7 @@
     layer_data *device_data = GetLayerDataPtr(get_dispatch_key(command_buffer), layer_data_map);
     bool skip = false;
     {
-        std::lock_guard<std::mutex> lock(global_lock);
+        boost::lock_guard<boost::mutex> lock(global_lock);
         skip |= ValidateObject(command_buffer, command_buffer, kVulkanObjectTypeCommandBuffer, false, VALIDATION_ERROR_16e02401,
                                VALIDATION_ERROR_UNDEFINED);
         if (begin_info) {
@@ -627,7 +627,7 @@
 // VK_EXT_debug_utils commands
 VKAPI_ATTR VkResult VKAPI_CALL SetDebugUtilsObjectNameEXT(VkDevice device, const VkDebugUtilsObjectNameInfoEXT *pNameInfo) {
     bool skip = VK_FALSE;
-    std::unique_lock<std::mutex> lock(global_lock);
+    boost::unique_lock<boost::mutex> lock(global_lock);
     skip |= ValidateObject(device, device, kVulkanObjectTypeDevice, false, VALIDATION_ERROR_UNDEFINED, VALIDATION_ERROR_UNDEFINED);
     lock.unlock();
     if (skip) {
@@ -646,7 +646,7 @@
 
 VKAPI_ATTR VkResult VKAPI_CALL SetDebugUtilsObjectTagEXT(VkDevice device, const VkDebugUtilsObjectTagInfoEXT *pTagInfo) {
     bool skip = VK_FALSE;
-    std::unique_lock<std::mutex> lock(global_lock);
+    boost::unique_lock<boost::mutex> lock(global_lock);
     skip |= ValidateObject(device, device, kVulkanObjectTypeDevice, false, VALIDATION_ERROR_UNDEFINED, VALIDATION_ERROR_UNDEFINED);
     lock.unlock();
     if (skip) {
@@ -659,7 +659,7 @@
 
 VKAPI_ATTR void VKAPI_CALL QueueBeginDebugUtilsLabelEXT(VkQueue queue, const VkDebugUtilsLabelEXT *pLabelInfo) {
     bool skip = VK_FALSE;
-    std::unique_lock<std::mutex> lock(global_lock);
+    boost::unique_lock<boost::mutex> lock(global_lock);
     skip |= ValidateObject(queue, queue, kVulkanObjectTypeQueue, false, VALIDATION_ERROR_UNDEFINED, VALIDATION_ERROR_UNDEFINED);
     lock.unlock();
     layer_data *dev_data = GetLayerDataPtr(get_dispatch_key(queue), layer_data_map);
@@ -673,7 +673,7 @@
 
 VKAPI_ATTR void VKAPI_CALL QueueEndDebugUtilsLabelEXT(VkQueue queue) {
     bool skip = VK_FALSE;
-    std::unique_lock<std::mutex> lock(global_lock);
+    boost::unique_lock<boost::mutex> lock(global_lock);
     skip |= ValidateObject(queue, queue, kVulkanObjectTypeQueue, false, VALIDATION_ERROR_UNDEFINED, VALIDATION_ERROR_UNDEFINED);
     lock.unlock();
     layer_data *dev_data = GetLayerDataPtr(get_dispatch_key(queue), layer_data_map);
@@ -687,7 +687,7 @@
 
 VKAPI_ATTR void VKAPI_CALL QueueInsertDebugUtilsLabelEXT(VkQueue queue, const VkDebugUtilsLabelEXT *pLabelInfo) {
     bool skip = VK_FALSE;
-    std::unique_lock<std::mutex> lock(global_lock);
+    boost::unique_lock<boost::mutex> lock(global_lock);
     skip |= ValidateObject(queue, queue, kVulkanObjectTypeQueue, false, VALIDATION_ERROR_UNDEFINED, VALIDATION_ERROR_UNDEFINED);
     lock.unlock();
     layer_data *dev_data = GetLayerDataPtr(get_dispatch_key(queue), layer_data_map);
@@ -701,7 +701,7 @@
 
 VKAPI_ATTR void VKAPI_CALL CmdBeginDebugUtilsLabelEXT(VkCommandBuffer commandBuffer, const VkDebugUtilsLabelEXT *pLabelInfo) {
     bool skip = VK_FALSE;
-    std::unique_lock<std::mutex> lock(global_lock);
+    boost::unique_lock<boost::mutex> lock(global_lock);
     skip |= ValidateObject(commandBuffer, commandBuffer, kVulkanObjectTypeCommandBuffer, false, VALIDATION_ERROR_UNDEFINED,
                            VALIDATION_ERROR_UNDEFINED);
     lock.unlock();
@@ -716,7 +716,7 @@
 
 VKAPI_ATTR void VKAPI_CALL CmdEndDebugUtilsLabelEXT(VkCommandBuffer commandBuffer) {
     bool skip = VK_FALSE;
-    std::unique_lock<std::mutex> lock(global_lock);
+    boost::unique_lock<boost::mutex> lock(global_lock);
     skip |= ValidateObject(commandBuffer, commandBuffer, kVulkanObjectTypeCommandBuffer, false, VALIDATION_ERROR_UNDEFINED,
                            VALIDATION_ERROR_UNDEFINED);
     lock.unlock();
@@ -731,7 +731,7 @@
 
 VKAPI_ATTR void VKAPI_CALL CmdInsertDebugUtilsLabelEXT(VkCommandBuffer commandBuffer, const VkDebugUtilsLabelEXT *pLabelInfo) {
     bool skip = VK_FALSE;
-    std::unique_lock<std::mutex> lock(global_lock);
+    boost::unique_lock<boost::mutex> lock(global_lock);
     skip |= ValidateObject(commandBuffer, commandBuffer, kVulkanObjectTypeCommandBuffer, false, VALIDATION_ERROR_UNDEFINED,
                            VALIDATION_ERROR_UNDEFINED);
     lock.unlock();
@@ -812,7 +812,7 @@
 
 VKAPI_ATTR VkResult VKAPI_CALL CreateDevice(VkPhysicalDevice physicalDevice, const VkDeviceCreateInfo *pCreateInfo,
                                             const VkAllocationCallbacks *pAllocator, VkDevice *pDevice) {
-    std::lock_guard<std::mutex> lock(global_lock);
+    boost::lock_guard<boost::mutex> lock(global_lock);
     bool skip = ValidateObject(physicalDevice, physicalDevice, kVulkanObjectTypePhysicalDevice, false, VALIDATION_ERROR_1fc27a01,
                                VALIDATION_ERROR_UNDEFINED);
     if (skip) return VK_ERROR_VALIDATION_FAILED_EXT;
@@ -854,7 +854,7 @@
 VKAPI_ATTR VkResult VKAPI_CALL GetSwapchainImagesKHR(VkDevice device, VkSwapchainKHR swapchain, uint32_t *pSwapchainImageCount,
                                                      VkImage *pSwapchainImages) {
     bool skip = false;
-    std::unique_lock<std::mutex> lock(global_lock);
+    boost::unique_lock<boost::mutex> lock(global_lock);
     skip |= ValidateObject(device, device, kVulkanObjectTypeDevice, false, VALIDATION_ERROR_30805601, VALIDATION_ERROR_UNDEFINED);
     skip |= ValidateObject(device, swapchain, kVulkanObjectTypeSwapchainKHR, false, VALIDATION_ERROR_3082f001,
                            VALIDATION_ERROR_UNDEFINED);
@@ -878,7 +878,7 @@
                                                          VkDescriptorSetLayout *pSetLayout) {
     bool skip = false;
     {
-        std::lock_guard<std::mutex> lock(global_lock);
+        boost::lock_guard<boost::mutex> lock(global_lock);
         skip |=
             ValidateObject(device, device, kVulkanObjectTypeDevice, false, VALIDATION_ERROR_1f805601, VALIDATION_ERROR_UNDEFINED);
         if (pCreateInfo) {
@@ -902,7 +902,7 @@
     VkResult result =
         get_dispatch_table(ot_device_table_map, device)->CreateDescriptorSetLayout(device, pCreateInfo, pAllocator, pSetLayout);
     if (VK_SUCCESS == result) {
-        std::lock_guard<std::mutex> lock(global_lock);
+        boost::lock_guard<boost::mutex> lock(global_lock);
         CreateObject(device, *pSetLayout, kVulkanObjectTypeDescriptorSetLayout, pAllocator);
     }
     return result;
@@ -913,7 +913,7 @@
                                                                   VkQueueFamilyProperties *pQueueFamilyProperties) {
     bool skip = false;
     {
-        std::lock_guard<std::mutex> lock(global_lock);
+        boost::lock_guard<boost::mutex> lock(global_lock);
         skip |= ValidateObject(physicalDevice, physicalDevice, kVulkanObjectTypePhysicalDevice, false, VALIDATION_ERROR_2da27a01,
                                VALIDATION_ERROR_UNDEFINED);
     }
@@ -922,7 +922,7 @@
     }
     get_dispatch_table(ot_instance_table_map, physicalDevice)
         ->GetPhysicalDeviceQueueFamilyProperties(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
-    std::lock_guard<std::mutex> lock(global_lock);
+    boost::lock_guard<boost::mutex> lock(global_lock);
     if (pQueueFamilyProperties != NULL) {
         layer_data *instance_data = GetLayerDataPtr(get_dispatch_key(physicalDevice), layer_data_map);
         if (instance_data->queue_family_properties.size() < *pQueueFamilyPropertyCount) {
@@ -978,7 +978,7 @@
 VKAPI_ATTR VkResult VKAPI_CALL EnumeratePhysicalDevices(VkInstance instance, uint32_t *pPhysicalDeviceCount,
                                                         VkPhysicalDevice *pPhysicalDevices) {
     bool skip = VK_FALSE;
-    std::unique_lock<std::mutex> lock(global_lock);
+    boost::unique_lock<boost::mutex> lock(global_lock);
     skip |=
         ValidateObject(instance, instance, kVulkanObjectTypeInstance, false, VALIDATION_ERROR_2800bc01, VALIDATION_ERROR_UNDEFINED);
     lock.unlock();
@@ -1002,7 +1002,7 @@
 VKAPI_ATTR VkResult VKAPI_CALL AllocateCommandBuffers(VkDevice device, const VkCommandBufferAllocateInfo *pAllocateInfo,
                                                       VkCommandBuffer *pCommandBuffers) {
     bool skip = VK_FALSE;
-    std::unique_lock<std::mutex> lock(global_lock);
+    boost::unique_lock<boost::mutex> lock(global_lock);
     skip |= ValidateObject(device, device, kVulkanObjectTypeDevice, false, VALIDATION_ERROR_16805601, VALIDATION_ERROR_UNDEFINED);
     skip |= ValidateObject(device, pAllocateInfo->commandPool, kVulkanObjectTypeCommandPool, false, VALIDATION_ERROR_02602801,
                            VALIDATION_ERROR_UNDEFINED);
@@ -1027,7 +1027,7 @@
 VKAPI_ATTR VkResult VKAPI_CALL AllocateDescriptorSets(VkDevice device, const VkDescriptorSetAllocateInfo *pAllocateInfo,
                                                       VkDescriptorSet *pDescriptorSets) {
     bool skip = VK_FALSE;
-    std::unique_lock<std::mutex> lock(global_lock);
+    boost::unique_lock<boost::mutex> lock(global_lock);
     skip |= ValidateObject(device, device, kVulkanObjectTypeDevice, false, VALIDATION_ERROR_16a05601, VALIDATION_ERROR_UNDEFINED);
     skip |= ValidateObject(device, pAllocateInfo->descriptorPool, kVulkanObjectTypeDescriptorPool, false, VALIDATION_ERROR_04c04601,
                            VALIDATION_ERROR_04c00009);
@@ -1057,7 +1057,7 @@
 VKAPI_ATTR void VKAPI_CALL FreeCommandBuffers(VkDevice device, VkCommandPool commandPool, uint32_t commandBufferCount,
                                               const VkCommandBuffer *pCommandBuffers) {
     bool skip = false;
-    std::unique_lock<std::mutex> lock(global_lock);
+    boost::unique_lock<boost::mutex> lock(global_lock);
     ValidateObject(device, device, kVulkanObjectTypeDevice, false, VALIDATION_ERROR_28405601, VALIDATION_ERROR_UNDEFINED);
     ValidateObject(device, commandPool, kVulkanObjectTypeCommandPool, false, VALIDATION_ERROR_28402801, VALIDATION_ERROR_28402807);
     for (uint32_t i = 0; i < commandBufferCount; i++) {
@@ -1080,7 +1080,7 @@
 
 VKAPI_ATTR void VKAPI_CALL DestroySwapchainKHR(VkDevice device, VkSwapchainKHR swapchain, const VkAllocationCallbacks *pAllocator) {
     layer_data *device_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
-    std::unique_lock<std::mutex> lock(global_lock);
+    boost::unique_lock<boost::mutex> lock(global_lock);
     // A swapchain's images are implicitly deleted when the swapchain is deleted.
     // Remove this swapchain's images from our map of such images.
     std::unordered_map<uint64_t, ObjTrackState *>::iterator itr = device_data->swapchainImageMap.begin();
@@ -1105,7 +1105,7 @@
                                                   const VkDescriptorSet *pDescriptorSets) {
     bool skip = false;
     VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
-    std::unique_lock<std::mutex> lock(global_lock);
+    boost::unique_lock<boost::mutex> lock(global_lock);
     skip |= ValidateObject(device, device, kVulkanObjectTypeDevice, false, VALIDATION_ERROR_28605601, VALIDATION_ERROR_UNDEFINED);
     skip |= ValidateObject(device, descriptorPool, kVulkanObjectTypeDescriptorPool, false, VALIDATION_ERROR_28604601,
                            VALIDATION_ERROR_28604607);
@@ -1132,7 +1132,7 @@
                                                  const VkAllocationCallbacks *pAllocator) {
     bool skip = VK_FALSE;
     layer_data *device_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
-    std::unique_lock<std::mutex> lock(global_lock);
+    boost::unique_lock<boost::mutex> lock(global_lock);
     skip |= ValidateObject(device, device, kVulkanObjectTypeDevice, false, VALIDATION_ERROR_24405601, VALIDATION_ERROR_UNDEFINED);
     skip |= ValidateObject(device, descriptorPool, kVulkanObjectTypeDescriptorPool, true, VALIDATION_ERROR_24404601,
                            VALIDATION_ERROR_24404607);
@@ -1161,7 +1161,7 @@
 VKAPI_ATTR void VKAPI_CALL DestroyCommandPool(VkDevice device, VkCommandPool commandPool, const VkAllocationCallbacks *pAllocator) {
     layer_data *device_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
     bool skip = false;
-    std::unique_lock<std::mutex> lock(global_lock);
+    boost::unique_lock<boost::mutex> lock(global_lock);
     skip |= ValidateObject(device, device, kVulkanObjectTypeDevice, false, VALIDATION_ERROR_24005601, VALIDATION_ERROR_UNDEFINED);
     skip |= ValidateObject(device, commandPool, kVulkanObjectTypeCommandPool, true, VALIDATION_ERROR_24002801,
                            VALIDATION_ERROR_24002807);
@@ -1195,7 +1195,7 @@
                                                                    VkQueueFamilyProperties2KHR *pQueueFamilyProperties) {
     bool skip = false;
     {
-        std::lock_guard<std::mutex> lock(global_lock);
+        boost::lock_guard<boost::mutex> lock(global_lock);
         skip |= ValidateObject(physicalDevice, physicalDevice, kVulkanObjectTypePhysicalDevice, false, VALIDATION_ERROR_UNDEFINED,
                                VALIDATION_ERROR_UNDEFINED);
     }
@@ -1204,7 +1204,7 @@
     }
     get_dispatch_table(ot_instance_table_map, physicalDevice)
         ->GetPhysicalDeviceQueueFamilyProperties2(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
-    std::lock_guard<std::mutex> lock(global_lock);
+    boost::lock_guard<boost::mutex> lock(global_lock);
     if (pQueueFamilyProperties != NULL) {
         layer_data *instance_data = GetLayerDataPtr(get_dispatch_key(physicalDevice), layer_data_map);
         if (instance_data->queue_family_properties.size() < *pQueueFamilyPropertyCount) {
@@ -1222,7 +1222,7 @@
                                                                       VkQueueFamilyProperties2KHR *pQueueFamilyProperties) {
     bool skip = false;
     {
-        std::lock_guard<std::mutex> lock(global_lock);
+        boost::lock_guard<boost::mutex> lock(global_lock);
         skip |= ValidateObject(physicalDevice, physicalDevice, kVulkanObjectTypePhysicalDevice, false, VALIDATION_ERROR_UNDEFINED,
                                VALIDATION_ERROR_UNDEFINED);
     }
@@ -1231,7 +1231,7 @@
     }
     get_dispatch_table(ot_instance_table_map, physicalDevice)
         ->GetPhysicalDeviceQueueFamilyProperties2KHR(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
-    std::lock_guard<std::mutex> lock(global_lock);
+    boost::lock_guard<boost::mutex> lock(global_lock);
     if (pQueueFamilyProperties != NULL) {
         layer_data *instance_data = GetLayerDataPtr(get_dispatch_key(physicalDevice), layer_data_map);
         if (instance_data->queue_family_properties.size() < *pQueueFamilyPropertyCount) {
@@ -1245,7 +1245,7 @@
 
 VKAPI_ATTR VkResult VKAPI_CALL DebugMarkerSetObjectNameEXT(VkDevice device, const VkDebugMarkerObjectNameInfoEXT *pNameInfo) {
     bool skip = VK_FALSE;
-    std::unique_lock<std::mutex> lock(global_lock);
+    boost::unique_lock<boost::mutex> lock(global_lock);
     layer_data *dev_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
     if (pNameInfo->pObjectName) {
         dev_data->report_data->debugObjectNameMap->insert(
--- layers/parameter_validation.h.orig	2018-06-07 16:51:23.538857100 +0100
+++ layers/parameter_validation.h	2018-06-07 16:51:38.492628400 +0100
@@ -26,7 +26,7 @@
 #include <string>
 #include <sstream>
 #include <bitset>
-#include <mutex>
+#include <boost/thread.hpp>
 #include <unordered_map>
 #include <unordered_set>
 
--- layers/unique_objects.h.orig	2018-06-07 17:08:47.922309600 +0100
+++ layers/unique_objects.h	2018-06-07 17:09:44.372149300 +0100
@@ -27,6 +27,7 @@
 #include "vk_layer_data.h"
 #include "vk_safe_struct.h"
 #include "vk_layer_utils.h"
+#include <boost/thread.hpp>
 #include "mutex"
 
 #pragma once
@@ -92,7 +93,7 @@
 static std::unordered_map<void *, instance_layer_data *> instance_layer_data_map;
 static std::unordered_map<void *, layer_data *> layer_data_map;
 
-static std::mutex global_lock;  // Protect map accesses and unique_id increments
+static boost::mutex global_lock;  // Protect map accesses and unique_id increments
 
 struct GenericHeader {
     VkStructureType sType;
--- layers/threading.cpp.orig	2018-06-07 17:15:10.203329300 +0100
+++ layers/threading.cpp	2018-06-07 17:16:03.509509300 +0100
@@ -404,7 +404,7 @@
     // Record mapping from command buffer to command pool
     if (VK_SUCCESS == result) {
         for (uint32_t index = 0; index < pAllocateInfo->commandBufferCount; index++) {
-            std::lock_guard<std::mutex> lock(command_pool_lock);
+            boost::lock_guard<boost::mutex> lock(command_pool_lock);
             command_pool_map[pCommandBuffers[index]] = pAllocateInfo->commandPool;
         }
     }
@@ -452,7 +452,7 @@
         // These updates need to be done before calling down to the driver.
         for (uint32_t index = 0; index < commandBufferCount; index++) {
             finishWriteObject(my_data, pCommandBuffers[index], lockCommandPool);
-            std::lock_guard<std::mutex> lock(command_pool_lock);
+            boost::lock_guard<boost::mutex> lock(command_pool_lock);
             command_pool_map.erase(pCommandBuffers[index]);
         }
     }
--- layers/parameter_validation_utils.cpp.orig	2018-06-07 17:20:51.307907300 +0100
+++ layers/parameter_validation_utils.cpp	2018-06-07 17:22:43.751284300 +0100
@@ -32,7 +32,7 @@
 #include <unordered_map>
 #include <unordered_set>
 #include <vector>
-#include <mutex>
+#include <boost/thread.hpp>
 
 #include "vk_loader_platform.h"
 #include "vulkan/vk_layer.h"
@@ -92,7 +92,7 @@
                                                      const VkAllocationCallbacks *pAllocator);
 
 // TODO : This can be much smarter, using separate locks for separate global data
-std::mutex global_lock;
+boost::mutex global_lock;
 
 static uint32_t loader_layer_if_version = CURRENT_LOADER_LAYER_INTERFACE_VERSION;
 std::unordered_map<void *, layer_data *> layer_data_map;
@@ -526,7 +526,7 @@
     bool skip = false;
     auto my_instance_data = GetLayerDataPtr(get_dispatch_key(physicalDevice), instance_layer_data_map);
     assert(my_instance_data != nullptr);
-    std::unique_lock<std::mutex> lock(global_lock);
+    boost::unique_lock<boost::mutex> lock(global_lock);
 
     skip |= parameter_validation_vkCreateDevice(physicalDevice, pCreateInfo, pAllocator, pDevice);
 
@@ -613,7 +613,7 @@
     bool skip = false;
     layer_data *device_data = GetLayerDataPtr(key, layer_data_map);
     {
-        std::unique_lock<std::mutex> lock(global_lock);
+        boost::unique_lock<boost::mutex> lock(global_lock);
         skip |= parameter_validation_vkDestroyDevice(device, pAllocator);
     }
 
@@ -647,7 +647,7 @@
     layer_data *local_data = GetLayerDataPtr(get_dispatch_key(device), layer_data_map);
     bool skip = false;
     VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
-    std::unique_lock<std::mutex> lock(global_lock);
+    boost::unique_lock<boost::mutex> lock(global_lock);
 
     skip |= ValidateDeviceQueueFamily(local_data, pCreateInfo->queueFamilyIndex, "vkCreateCommandPool",
                                       "pCreateInfo->queueFamilyIndex", VALIDATION_ERROR_02c0004e);
@@ -695,7 +695,7 @@
     VkResult result = VK_ERROR_VALIDATION_FAILED_EXT;
 
     {
-        std::unique_lock<std::mutex> lock(global_lock);
+        boost::unique_lock<boost::mutex> lock(global_lock);
         skip |= parameter_validation_vkCreateRenderPass(device, pCreateInfo, pAllocator, pRenderPass);
 
         typedef bool (*PFN_manual_vkCreateRenderPass)(VkDevice device, const VkRenderPassCreateInfo *pCreateInfo,
@@ -711,7 +711,7 @@
 
         // track the state necessary for checking vkCreateGraphicsPipeline (subpass usage of depth and color attachments)
         if (result == VK_SUCCESS) {
-            std::unique_lock<std::mutex> lock(global_lock);
+            boost::unique_lock<boost::mutex> lock(global_lock);
             const auto renderPass = *pRenderPass;
             auto &renderpass_state = device_data->renderpasses_states[renderPass];
 
@@ -738,7 +738,7 @@
     bool skip = false;
 
     {
-        std::unique_lock<std::mutex> lock(global_lock);
+        boost::unique_lock<boost::mutex> lock(global_lock);
         skip |= parameter_validation_vkDestroyRenderPass(device, renderPass, pAllocator);
 
         typedef bool (*PFN_manual_vkDestroyRenderPass)(VkDevice device, VkRenderPass renderPass,
@@ -754,7 +754,7 @@
 
         // track the state necessary for checking vkCreateGraphicsPipeline (subpass usage of depth and color attachments)
         {
-            std::unique_lock<std::mutex> lock(global_lock);
+            boost::unique_lock<boost::mutex> lock(global_lock);
             device_data->renderpasses_states.erase(renderPass);
         }
     }
--- layers/threading.h.orig	2018-06-07 17:27:48.891877400 +0100
+++ layers/threading.h	2018-06-07 17:29:03.655168300 +0100
@@ -84,7 +84,7 @@
     VkDebugReportObjectTypeEXT objectType;
     std::unordered_map<T, object_use_data> uses;
     boost::mutex counter_lock;
-    std::condition_variable counter_condition;
+    boost::condition_variable counter_condition;
     void startWrite(debug_report_data *report_data, T object) {
         if (object == VK_NULL_HANDLE) {
             return;
--- layers/CMakeLists.txt.orig	2018-06-07 17:35:51.046043100 +0100
+++ layers/CMakeLists.txt	2018-06-07 17:36:25.172310400 +0100
@@ -154,7 +154,7 @@
     set_target_properties(copy-${target}-def-file PROPERTIES FOLDER ${LVL_TARGET_FOLDER})
     add_library(VkLayer_${target} SHARED ${ARGN} VkLayer_${target}${DEFFILE_SUFFIX}.def)
     add_dependencies(VkLayer_${target} generate_helper_files)
-    target_link_Libraries(VkLayer_${target} VkLayer_utils)
+    target_link_Libraries(VkLayer_${target} boost_thread-mt boost_system-mt VkLayer_utils)
     add_dependencies(VkLayer_${target} generate_helper_files VkLayer_utils)
     if(MINGW)
       install(TARGETS VkLayer_${target} RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR} LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR} ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR})
@@ -165,10 +165,10 @@
     add_library(VkLayer_${target} SHARED ${ARGN})
     target_link_Libraries(VkLayer_${target} VkLayer_utils)
     add_dependencies(VkLayer_${target} generate_helper_files VkLayer_utils)
-    set_target_properties(VkLayer_${target} PROPERTIES 
+    set_target_properties(VkLayer_${target} PROPERTIES
         LINK_FLAGS "-Wl"
         INSTALL_RPATH "@loader_path/"
-    ) 
+    )
     install(TARGETS VkLayer_${target} DESTINATION ${CMAKE_CURRENT_BINARY_DIR})
     endmacro()
 else()
@@ -208,7 +208,7 @@
 
 # Clang (and not gcc) warns about unused const variables.
 # Generated files may purposely contain unused consts, so
-# silence this warning in Clang. 
+# silence this warning in Clang.
 if (CMAKE_C_COMPILER_ID MATCHES "Clang")
    set_source_files_properties(parameter_validation.cpp PROPERTIES
         COMPILE_FLAGS "-Wno-unused-const-variable")
